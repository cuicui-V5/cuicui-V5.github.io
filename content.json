{"posts":[{"title":"JavaScript使用WebSocket","text":"使用 WebSocket 可以实现点对点的全双工即时通信 ws 客户端的基本使用 123456789101112131415var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function (evt) { console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSockets!&quot;);};ws.onmessage = function (evt) { console.log(&quot;Received Message: &quot; + evt.data); ws.close();};ws.onclose = function (evt) { console.log(&quot;Connection closed.&quot;);}; 新建实例 1var ws = new WebSocket(&quot;ws://localhost:8080&quot;); 注意: 不能 catch 住 websocket 的超时 error 的 webSocket.readyState 返回实例的当前状态 1234CONNECTING：值为0，表示正在连接。OPEN：值为1，表示连接成功，可以通信了。CLOSING：值为2，表示连接正在关闭。CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 webSocket.onopen 实例对象的onopen属性，用于指定连接成功后的回调函数。 123ws.addEventListener(&quot;open&quot;, function (event) { ws.send(&quot;Hello Server!&quot;);}); webSocket.onclose 实例对象的onclose属性，用于指定连接关闭后的回调函数。 123456ws.addEventListener(&quot;close&quot;, function (event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event}); webSocket.onmessage 实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。 1234ws.addEventListener(&quot;message&quot;, function (event) { var data = event.data; // 处理数据}); webSocket.send() 实例对象的send()方法用于向服务器发送数据。 1ws.send(&quot;your message&quot;); webSocket.onerror 实例对象的onerror属性，用于指定报错时的回调函数。 123socket.addEventListener(&quot;error&quot;, function (event) { // handle error event}); ws 服务器端 首先引入ws模块, 然后与客户端类似, 新建 socket 实例 使用socket.send()发送数据 使用 socket.addEventListener(&quot;message&quot;, ({data}) =&gt; {})或socket.on(&quot;messgae&quot;,()=&gt;{}) 接收数据 1234567891011121314151617181920212223import { WebSocketServer } from &quot;ws&quot;;const server = new WebSocketServer({ port: 1234 });server.on(&quot;connection&quot;, (socket) =&gt; { // 向客户端发送消息 socket.send( JSON.stringify({ msg: &quot;hello from server&quot;, code: &quot;200&quot;, }), ); // 从客户端接收消息 socket.on(&quot;message&quot;, (data) =&gt; { console.log(data); const packet = JSON.parse(data); console.log(packet); }); socket.addEventListener(&quot;message&quot;, ({ data }) =&gt; { console.log(data); });}); 获取所有连接 每个 ws 连接都为一个独立的socket实例 使用server.clients列出所有连接 向每个连接广播消息: 123456const boardCast = () =&gt; { dataObj.onlineUser = ws.clients.size; ws.clients.forEach((client) =&gt; { client.send(JSON.stringify(dataObj)); });};","link":"/20221123/JavaScript%E4%BD%BF%E7%94%A8WebSocket/"},{"title":"Git批量修改已提交的邮箱信息","text":"新建 rename.sh 内容如下 1234567891011121314151617181920#!/bin/shgit filter-branch --env-filter 'OLD_EMAIL=&quot;原邮箱地址&quot;CORRECT_NAME=&quot;新用户名&quot;CORRECT_EMAIL=&quot;新邮箱地址&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot; export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot; export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi' --tag-name-filter cat -- --branches --tags 使用 git bash 运行 1sh rename.sh 强行提交 1git push origin --force --all","link":"/20220511/Git%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%8F%90%E4%BA%A4%E7%9A%84%E9%82%AE%E7%AE%B1%E4%BF%A1%E6%81%AF/"},{"title":"CSS实现遮罩效果","text":"123background: url(@/img/bg.jpg) rgba(0, 0, 0, 0.3);background-size: cover;background-blend-mode: multiply;","link":"/20221216/CSS%E5%AE%9E%E7%8E%B0%E9%81%AE%E7%BD%A9%E6%95%88%E6%9E%9C/"},{"title":"vue vee-validate 表单验证","text":"使用步骤 使用第三包提供的Form标签将表单整个区域包裹起来, 如果要进行整体验证, 需要给Form打ref 使用第三方包提供的Filed标签将输入框的input替换掉 如果表单需要校验，那么必须有name属性 将校验规则通过rules绑定到需要校验的Field标签上 当用户输入的内容未通过验证规则时，错误信息是从Form标签上的插槽中解构出来的 引入组件 1import { Form, Field } from &quot;vee-validate&quot;; 模板写法 1234567891011121314151617181920212223242526272829303132333435&lt;Form v-slot=&quot;{ errors }&quot; ref=&quot;fromValidate&quot;&gt; &lt;div class=&quot;input-text clearFix&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;Field type=&quot;text&quot; placeholder=&quot;邮箱/用户名/手机号&quot; v-model=&quot;phone&quot; name=&quot;account&quot; :rules=&quot;checkAccount&quot; /&gt; &lt;h1 style=&quot;color: red&quot;&gt;{{ errors.account }}&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;input-text clearFix&quot;&gt; &lt;span class=&quot;pwd&quot;&gt;&lt;/span&gt; &lt;Field type=&quot;text&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;password&quot; name=&quot;password&quot; :rules=&quot;checkPassword&quot; /&gt; &lt;h1 style=&quot;color: red&quot;&gt; {{ errors.password }} &lt;/h1&gt; &lt;/div&gt; &lt;button class=&quot;btn&quot; @click.prevent=&quot;login&quot; &gt; 登&amp;nbsp;&amp;nbsp;录 &lt;/button&gt;&lt;/Form&gt; 书写验证规则 1234567891011121314151617181920// 定义验证规则const checkAccount = (val: unknown) =&gt; { const reg = /^[\\a-zA-Z0-9_]+$/; if (!val) { return &quot;请输入账号&quot;; } else { if (reg.test(val as string)) { return true; } else { return &quot;账号不合法 请输入6-16位数字字母下划线&quot;; } }};const checkPassword = (val: unknown) =&gt; { if (!val) { return &quot;请输入密码&quot;; } else { return true; }}; 进行整体验证 123456789const login = async () =&gt; { const { valid } = await fromValidate.value?.validate(); console.log(valid); if (valid) { // 如果验证通过进行下一步 ... }};","link":"/20230106/vue-vee-validate-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"},{"title":"TypeScript下给定时器标注类型","text":"12let timer: NodeJS.Timeout = setInterval(() =&gt; {});clearTimeout(timer);","link":"/20220720/TypeScript%E4%B8%8B%E7%BB%99%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A0%87%E6%B3%A8%E7%B1%BB%E5%9E%8B/"},{"title":"JavaScript数组总结","text":"js 中的数组拥有众多方法, 在这里我加以总结便于复习 数组的定义 12let arr = new Array(1, 2, 3);let arr = [1, 2, 3]; 检测是否为数组 使用 instanceof 运算符 instanceof 可以判断原型是否处于原型链上 12arr=[1,2,3];console.log(arr instanceof Array); //输出true 使用 Array.isArray()方法 12arr=[1,2,3];console.log(Array.isArray(arr)); //输出true 数组方法 数组操作方法 push() 向数组后方添加一个或多个元素, 改变原数组, 返回数组长度 1arr.push(10, 20); unshift() 在数组前方添加一或多个元素, 改变原数组, 返回数组长度 1arr.unshitf(1, 2, 3); ‍ pop() 删除数组后方的元素, 改变原数组, 返回删除的内容 1arr.pop(); shift() 删除数组前方的元素, 改变原数组, 返回删除的内容 1arr.shift(); ‍ splice() 在指定位置删除或添加元素, 改变原数组, 返回删除的元素组成的数组 用法: ​splice(操作元素的下标, 删除几个元素, 要添加的元素...)​ 1234arr = [1, 2, 3];arr.splice(1, 1, 4, 5, 6);//arr [1,4,5,6,3] ‍ 数组排序 reverse() ​reverse() ​​ 可以翻转数组 12arr=[1,2,3,4,5];arr.reverse(); sort() 对数组进行排序, 改变原数组, 返回排序结果 用法: ​arr.sort(排序函数)​ 排序函数: 排序函数传入两个参数, 分别为依次比较的两个元素, 如果返回大于 0 的值, 就交换位置, 如果小于 0, 就不交换 12arr.sort((a, b) =&gt; a - b); // 升序arr.sort((a, b) =&gt; b - a); // 降序 连接数组 concat 用来连接两个数组, 不改变原数组, 返回连接后的数组 语法: arr1.concat(arr2, arr3)​ 1arr.concat(arr2, [1, 2, 3]); ‍ 数组迭代方法 数组迭代方法都不会更改原数组 every() 判断数组元素是否全部符合某个条件, 返回 true ​ 或 false​ 语法: every(item=&gt;true)​ 如果回调函数全部返回 true​, 那么才返回 true​, 否则就是 false​ 12arr = [1, 2, 3, 4, 5];arr.every((item) =&gt; item % 2 == 0); // false some() 判断数组元素是否符合条件, 只要有一个符合条件就返回 true​ 语法: some(item=&gt;true)​ 只要回调函数有一个返回了 true​, 那么 some ​ 的返回值就为 true​, 只有全部都是 false​, 那么才是 false​ 12arr = [1, 2, 3, 4, 5];arr.some((item) =&gt; item % 2 == 0); // true filter() 返回一个符合条件的新数组, 用于从数组内部筛选元素 语法: filter(item=&gt;item)​ filter 会遍历数组的每一个元素传入回调函数, 如果回调返回 true, 那么这个元素就会被加入返回的数组内 1234arr = [1, 3, 4, 5, 6];arr.filter((item) =&gt; item % 2 == 0);// [ 4, 6 ] ‍ map() 返回回调函数返回值组成的数组, 可以用来处理数组 语法: map(item=&gt;item)​ map 会遍历数组的每一个元素传入回调函数, 并将回调函数的返回值放入 map 返回的数组中 1234&gt; arr=[1,2,3,4,5][ 1, 2, 3, 4, 5 ]&gt; arr.map(item=&gt;item+10)[ 11, 12, 13, 14, 15 ] foreach() 无返回值, 遍历数组每个元素并执行回调函数 123456789&gt; arr=[1,2,3,4,5][ 1, 2, 3, 4, 5 ]&gt; arr.forEach((item,index)=&gt;{console.log(item,index)})1 02 13 24 35 4undefined reduce() 详情参阅 https://www.freecodecamp.org/chinese/news/the-ultimate-guide-to-javascript-array-methods-reduce/ 用来处理数组, 最后返回一个任意类型的值 语法: arr.reduce((pre,current)=&gt;{},initVal)​ 参数: ​pre​ :上次迭代的结果 ​current​: 当前迭代的值 ​initVal​: 初始值 执行过程: reduce ​ 方法会迭代数组内所有值, 并且会把上次 return ​ 的执行结果作为当前的 pre ​ 参数 注意: reduce ​ 中一定要使用 return ​ 返回值 12345678910111213141516171819202122232425262728293031323334353637383940// 累加值let arr = [1, 2, 3, 4, 5];let res = arr.reduce((sum, val) =&gt; { sum += val; return sum;}, 0);console.log(res);// 拼合字符串let arr2 = [&quot;小明&quot;, &quot;小红&quot;, &quot;小强&quot;];let res2 = arr2.reduce((sum, val) =&gt; { sum += val; return sum;}, &quot;&quot;);console.log(res2);// 求每个人的年龄和let arr3 = [ { name: &quot;小明&quot;, age: 20, }, { name: &quot;小hs&quot;, age: 30, }, { name: &quot;小a&quot;, age: 50, },];let res3 = arr3.reduce((sum, val) =&gt; { sum += val.age; return sum;}, 0);console.log(res3); ‍ 生成数组方法 from() 可以将伪数组(例如函数的 arguments​)转换为真正的数组, 返回转换完成的数组 1Array.from(arguments); 还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组 12Array.from([1, 2, 3], (x) =&gt; x * x);// [1, 4, 9] 数组搜索方法 ​index​ 系列方法直接传入要搜索的值, find​ 系列方法传入回调 indexOf() 返回搜索结果所在的下标, 如果没有结果那么返回 **-1**​ 1234&gt; arr[ 1, 2, 3, 4, 5 ]&gt; arr.indexOf(3)2 lastIndexOf() 从后面开始搜索, 返回搜索结果所在的下标, ​ 如果没有结果那么返回 **-1**​ 1234567&gt; arr=[11,12,12,13,11,11,12,13][ 11, 12, 12, 13, 11, 11, 12, 13]&gt; arr.lastIndexOf(11)5 includes() 搜索数组, 如果包含参数值, 返回true​, 否则返回false​ 12&gt; arr.includes(11)true find() 传入一个回单函数, find​返回第一个回调函数返回 true 的元素 1234567&gt; arr=[11,12,12,13,11,11,12,13][ 11, 12, 12, 13, 11, 11, 12, 13]&gt; arr.find(item=&gt;item&gt;0)11 ‍ findIndex() 传入一个回单函数, find​返回第一个回调函数返回 true 的元素的下标 12&gt; arr.findIndex(item=&gt;item&gt;12)3 findLast() 与find​ 类似, 从后查找 findLastIndex() 与findIndex​ 类似, 从后查找","link":"/20221205/JavaScript%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"},{"title":"Vue3中 v-model封装自定义组件实现数据双向绑定","text":"v-model 传进来的数据为modelValue, 要手动触发的事件为update:modelValue 父组件 123456&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;{{ msg }}&lt;/h1&gt; &lt;test v-model=&quot;msg&quot;&gt;&lt;/test&gt; &lt;/div&gt;&lt;/template&gt; 子组件 12345678910111213141516&lt;template&gt; &lt;div&gt; 请输入 &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;$emit('update:modelValue', $event.target.value)&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { props: [&quot;modelValue&quot;],};&lt;/script&gt;","link":"/20230114/Vue3%E4%B8%AD-v-model%E5%B0%81%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"},{"title":"Vue封装一个分页器组件","text":"一个分页器组件最重要的四个参数(需要外界传入) 当前第几页: pageNo 每页展示的数据数量: pageSize 共有多少数据: total 显示的连续页码: continues 通过以上信息可以计算出来的数据 共有多少页: total/pageSize 向上取整 显示的连续页码的起始与结束 如果总页数小于要显示的连续页码 起始为 1 结束为总页数 如果总页数大于连续页码 先计算出当前页码左边和右边要显示几个页码: 连续页码/2 向下取整 起始页码: 当前显示的页码-上边计算出来的数据 如果小于 1, 那么起始页码等于 1, 结束页码等于要显示的连续页码 结束页码: 当前显示的页码+上边计算出来的数据 如果大于总页码, 那么起始页码等于总页码-连续页码+1, 结束页码等于总页码 分页器组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;template&gt; &lt;div class=&quot;pagination&quot;&gt; &lt;button :disabled=&quot;pageNo == 1&quot; @click=&quot;emit('changePage', pageNo - 1)&quot; &gt; 上一页 &lt;/button&gt; &lt;button v-if=&quot;startAndEnd.start &gt; 1&quot;&gt;1&lt;/button&gt; &lt;button v-if=&quot;startAndEnd.start &gt; 2&quot;&gt;···&lt;/button&gt; &lt;button :class=&quot;{ active: pageNo == index + 1, }&quot; v-for=&quot;(page, index) in startAndEnd.end&quot; v-show=&quot;page &gt;= startAndEnd.start&quot; @click=&quot;emit('changePage', index + 1)&quot; &gt; {{ page }} &lt;/button&gt; &lt;button v-if=&quot;startAndEnd.end &lt; totalPage - 1&quot;&gt;···&lt;/button&gt; &lt;button v-if=&quot;startAndEnd.end &lt; totalPage&quot;&gt;{{ totalPage }}&lt;/button&gt; &lt;button :disabled=&quot;pageNo == totalPage&quot; @click=&quot;emit('changePage', pageNo + 1)&quot; &gt; 下一页 &lt;/button&gt; &lt;button style=&quot;margin-left: 30px&quot;&gt;共 {{ total }} 条&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import { computed, toRefs, type Ref } from &quot;vue&quot;; const props = defineProps&lt;{ pageNo: number; pageSize: number; total: number; continues: number; }&gt;(); const { pageNo, pageSize, total, continues } = toRefs(props); const emit = defineEmits([&quot;changePage&quot;]); const totalPage = computed(() =&gt; { return Math.ceil(total.value / pageSize.value); }); const test = () =&gt; { console.log(pageNo.value); }; const startAndEnd = computed(() =&gt; { let start = 0, end = 0; console.log(pageNo.value); // 如果总页数小于要显示的页数 if (totalPage.value &lt; continues.value) { start = 1; end = totalPage.value; } else { // 正常情况 start = pageNo.value - Math.floor(continues.value / 2); end = pageNo.value + Math.floor(continues.value / 2); } // 异常情况 if (start &lt; 1) { start = 1; end = continues.value; } if (end &gt; totalPage.value) { start = totalPage.value - continues.value + 1; end = totalPage.value; } // debugger; return { start, end, }; });&lt;/script&gt;&lt;script lang=&quot;ts&quot;&gt; export default { name: &quot;pagination&quot;, };&lt;/script&gt; 使用分页器组件 12345678910111213141516 &lt;pagination v-if=&quot;store.searchList&quot; :pageNo=&quot;searchParams.pageNo&quot; :pageSize=&quot;searchParams.pageSize&quot; :total=&quot;store.searchList.total&quot; :continues=&quot;5&quot; @changePage=&quot;changePage&quot; &gt;&lt;/pagination&gt;//改变页码并且发送请求 const changePage = (pageNo: number) =&gt; { console.log(pageNo); searchParams.value.pageNo = pageNo; store.getSearchList(searchParams.value); };","link":"/20221204/Vue%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%88%86%E9%A1%B5%E5%99%A8%E7%BB%84%E4%BB%B6/"},{"title":"纯CSS实现全屏滚动效果","text":"实现全屏滚动可以不依赖 JS, 只使用纯 CSS 实现, 不过只有较新版本的浏览器支持这一特性 主要使用了以下 CSS 属性 scroll-snap-type: y mandatory; 给父元素设置, 设置贴合类型 scroll-snap-align: start; 给子元素设置, 设置贴合点 123456&lt;main&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt;&lt;/main&gt; 容器布局 123456789101112131415&lt;style&gt; main { width: 100vw; height: 100vh; scroll-snap-type: y mandatory; overflow: scroll; } main div { border: black 2px solid; scroll-snap-align: start; width: 100vw; height: 100vh; background-color: skyblue; }&lt;/style&gt; 样式设置","link":"/20230213/%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C/"},{"title":"数据结构学习-栈","text":"栈结构遵循以下规则 数据从栈顶 (又称为栈尾) 进入 从栈顶退出 遵循后进先出的 LIFO 原则 一个栈应该有以下方法: push pop peek isEmpty size clear toString 封装一个栈 12345678910111213141516171819202122232425262728293031323334// 一个栈应该有以下方法: push pop peek isEmpty size clear toStringclass Stack { private stack: unknown[] = []; push(data: unknown) { this.stack.push(data); } pop() { return this.stack.pop(); } // 返回栈顶元素 peek() { return this.stack[this.stack.length - 1]; } isEmpty() { return this.stack.length === 0; } size() { return this.stack.length; } clear() { this.stack = []; } toString() { return this.stack.join(&quot;-&quot;); }}const stack = new Stack();debugger; 应用: 进制转换 123456789101112131415161718import { Stack } from &quot;./stack&quot;;// 进制转换 利用辗转相除法function convert(DecNumber: number, base: number) { const remStack = new Stack(); const baseString = &quot;0123456789ABCDEF&quot;; let res = &quot;&quot;; while (DecNumber &gt; 0) { remStack.push(DecNumber % base); DecNumber = Math.floor(DecNumber / base); } while (!remStack.isEmpty()) { res += baseString[remStack.pop() as number]; } return res;}console.log(convert(1234, 16));","link":"/20221214/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0-%E6%A0%88/"},{"title":"JavaScript实现图片压缩","text":"图片等比缩小的方法 图片压缩的基本思路 压缩图片主要利用了canvas的toBlob方法, toBlob方法可以将canvas画布的画面转换成Blob对象, 同时设置质量 获取input数据, 使用fileReader转换成 dataUrl 将dataUrl的值赋给image的src 将image绘制进canvas, 注意这里可以对图片尺寸进行控制 使用canvas.toBlob获取 blob 对象, 可以在其中设置压缩比例 上传图片 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 上传图片压缩的步骤// 1. 获取input数据, 使用fileReader转换成dataUrl// 2. 将dataUrl的值赋给image的src// 3. 将image绘制进canvas// 4. 使用canvas.toBlob获取blob对象, 可以在其中设置压缩比例// 5. 上传图片const fileToImg = (file: File): Promise&lt;HTMLImageElement&gt; =&gt; { return new Promise((resolve, reject) =&gt; { const reader = new FileReader(); const img = new Image(); // 将传进来的file转换成dataURl reader.readAsDataURL(file); reader.onload = () =&gt; { img.src = reader.result as string; }; reader.onerror = (e) =&gt; { reject(e); }; img.onload = () =&gt; { resolve(img); }; img.onerror = (e) =&gt; { reject(e); }; });};const imgToBlob = ( img: HTMLImageElement, maxWidth: number, maxHeight: number, quality: number, type = &quot;image/png&quot;,): Promise&lt;Blob&gt; =&gt; { return new Promise((resolve, reject) =&gt; { const canvas = document.createElement(&quot;canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;); // 获取图片原始尺寸 const { width: originWidth, height: originHeight } = img; // 确定目标尺寸 let targetWidth = originWidth, targetHeight = originHeight; // 如果图片尺寸大于目标尺寸, 那么就进行等比缩放 if (targetWidth &gt; maxWidth || targetHeight &gt; maxHeight) { // 等比缩小的算法 // 如果是横着的图, 图片的宽等于最大宽度, 高等比缩放; // 如果是竖着的图, 图片的高等于最大高度, 宽等比缩放; // 先判断是横着的图还是竖着的图 if (targetWidth &gt; targetHeight) { //横着的 targetWidth = maxWidth; targetHeight = targetHeight * (maxWidth / originWidth); } else { //竖着的 targetHeight = maxHeight; targetWidth = targetWidth * (maxHeight / originHeight); } } try { // 把img绘制进canvas canvas.width = targetWidth; canvas.height = targetHeight; ctx?.clearRect(0, 0, targetWidth, targetHeight); ctx?.drawImage(img, 0, 0, targetWidth, targetHeight); // 获取blob对象 canvas.toBlob( (blob) =&gt; { if (blob) { resolve(blob); } else { reject(new Error(&quot;转换失败&quot;)); } }, type, quality, ); } catch (error) { reject(error); } });};const inp = document.querySelector(&quot;#input&quot;);inp?.addEventListener(&quot;change&quot;, async (e) =&gt; { const inputEle = e.target as HTMLInputElement; if (inputEle.files?.length) { const img = await fileToImg(inputEle.files[0]); const blob = await imgToBlob(img, 1000, 1000, 0.2); console.log(blob); }});","link":"/20230203/JavaScript%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"},{"title":"Chrome 单独清除某个网页的缓存","text":"打开该网页 打开开发者工具 长按刷新按钮 选择 清空缓存并硬性重新加载","link":"/20230216/Chrome-%E5%8D%95%E7%8B%AC%E6%B8%85%E9%99%A4%E6%9F%90%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E7%BC%93%E5%AD%98/"},{"title":"JavaScript获取剪贴板文件","text":"1234const btn = document.querySelector(&quot;button&quot;);document.addEventListener(&quot;paste&quot;, (e) =&gt; { console.log(e.clipboardData.files);});","link":"/20230113/JavaScript%E8%8E%B7%E5%8F%96%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%96%87%E4%BB%B6/"},{"title":"TS+ESM项目导入自定义模块不加扩展名就报错的问题","text":"折腾了两个小时，我基本弄明白了如何在 TypeScript 中使用自定义的 ESM 模块。 一开始以为直接导入文件名就行，不需要扩展名。但是，这样使用 TSC 编译出来之后运行报错，因为 ESM 规范要求导入自定义模块必须带有扩展名。然而，TSC 编译出来的项目中导入模块是不带扩展名的，所以 Node.js 会报错。 于是，我想当然地写了 import router from &quot;./router.ts&quot;;，认为 TypeScript 会自动处理扩展名。然而，并不是这样的。 TypeScript 直接不允许导入 .ts 后缀的文件，要求启用 allowImportingTsExtensions。但是加了这个选项之后，出现了更多的错误： 12error TS2691: An import path cannot end with a '.ts' extension. Consider importing './router.js' instead.error TS2835: Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Did you mean './event.js'? 关于这个问题，在 GitHub 上有相关的讨论：https://github.com/microsoft/TypeScript/issues/16577 解决方案 在 tsconfig.json 中将 moduleResolution 设置为 nodenext。设置之后，VS Code 导入模块时会自动加上 .js 后缀。 使用 import router from &quot;./router.js&quot;;，注意这里扩展名为 .js。 实际上，上面的报错也说明了问题：“An import path cannot end with a ‘.ts’ extension. Consider importing ‘./router.js’ instead.”（导入路径不能以 .ts 结尾，考虑导入 ‘./router.js’） 非常坑啊有没有，明明是 TypeScript，为什么要导入 JavaScript 呢？ ChatGPT 给出了解释： 您在 TypeScript 中导入模块时，使用的是相对路径或绝对路径来引用另一个文件。这与 JavaScript 中的导入语句类似。 当 TypeScript 编译器将 TypeScript 代码转换为 JavaScript 代码时，它会自动将 .ts 扩展名更改为 .js 扩展名，并生成一个新的 JavaScript 文件，其中包含编译后的 JavaScript 代码。 因此，即使您在 TypeScript 代码中导入的是 .ts 文件，最终在运行时实际上会加载并执行 .js 文件，因此需要在导入语句中指定 .js 扩展名。","link":"/20230306/TS+ESM%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97%E4%B8%8D%E5%8A%A0%E6%8B%93%E5%B1%95%E5%90%8D%E5%B0%B1%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98/"},{"title":"为 Vue 项目开启 PWA","text":"之前的网络上的教程都是 vue/cli 的, 经过我的一番摸索, 终于弄明白了 vite+vue3+pwa 的正确打开方式 安装 ​ vite-plugin-pwa npm i vite-plugin-pwa -D 配置 vite-plugin-pwa 1234import { VitePWA } from &quot;vite-plugin-pwa&quot;;export default defineConfig({ plugins: [VitePWA({ registerType: &quot;autoUpdate&quot; })],}); 使 PWA 可安装 一开始配置好后, 浏览器并没有提示可以安装, 经过一晚上的摸索(看文档), 最终总结如下 使 PWA 可安装的前置要求: https://vite-pwa-org.netlify.app/guide/pwa-minimal-requirements.html 必须?同时满足以下条件 index.html 中的 &lt;head&gt; 标签中配置如下条目 viewport title 标签 description favicon apple-touch-icon mask-icon theme-color Manifest 清单文件中有如下配置 a scope: omitted here for simplicity, the vite-plugin-pwa plugin will use the Vite base option to configure it (default is /) a name a short description a description a theme_color: must match the configured one on Entry Point theme-color an icon with 192x192 size an icon with 512x512 size 也就是 vite.config.js 进行如下配置 123456789101112131415161718192021222324252627282930import { VitePWA } from &quot;vite-plugin-pwa&quot;;export default defineConfig({ plugins: [ VitePWA({ includeAssets: [ &quot;favicon.ico&quot;, &quot;apple-touch-icon.png&quot;, &quot;masked-icon.svg&quot;, ], manifest: { name: &quot;My Awesome App&quot;, short_name: &quot;MyApp&quot;, description: &quot;My Awesome App description&quot;, theme_color: &quot;#ffffff&quot;, icons: [ { src: &quot;pwa-192x192.png&quot;, sizes: &quot;192x192&quot;, type: &quot;image/png&quot;, }, { src: &quot;pwa-512x512.png&quot;, sizes: &quot;512x512&quot;, type: &quot;image/png&quot;, }, ], }, }), ],}); 配置 robots.txt 12User-agent: *Allow: / 服务端满足以下要求 https://vite-pwa-org.netlify.app/deployment/ serve manifest.webmanifest with application/manifest+json mime type 必须使用 https http ​ 重定向 https","link":"/20230220/%E4%B8%BA-Vue-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%90%AF-PWA/"},{"title":"利用pandoc合并markdown及转换为docx","text":"最近有需求把 markdown 文档合并起来然后转换为 word 文档以供打印的需求, 所以了解到了 pandoc 这一款命令行文本处理神器 批量合并 markdown 小 tips: 如果需要大批量文件, 可以在资源管理器中全选, 然后拖到终端窗口中, 自动填充路径及文件名 1pandoc -s file1.md file2.md -o AllJavaScript.md markdown 转 doc 1pandoc -o output.docx -f markdown -t docx .\\AllInOne.md","link":"/20230120/%E5%88%A9%E7%94%A8pandoc%E5%90%88%E5%B9%B6markdown%E5%8F%8A%E8%BD%AC%E6%8D%A2%E4%B8%BAdocx/"},{"title":"通过Acme.sh + CloudFlare Dns认证申请泛域名证书","text":"使用 acme.sh 这个神器, 可以快速的申请泛域名证书, 省去繁琐的手动申请的步骤 由于我的域名使用了 CloudFlare Dns , 所以我用了 CloudFlare 的 api 认证方式 使用步骤 首先在 CloudFlare 控制面板中获取 api key ,此处不多赘述 设置环境变量 12export CF_Key=&quot;cloudflare申请的apikey&quot;export CF_Email=&quot;你的邮箱&quot; 使用 acme.sh 注册 acme 账号 1acme.sh --register-account -m 你的邮箱 使用 acme.sh 快速申请泛域名证书, 并安装到 nginx 路径 1234acme.sh --issue -d &quot;cuijunyu.win&quot; -d &quot;*.cuijunyu.win&quot; --dns dns_cf \\--key-file /etc/nginx/ssl/cuijunyu.key \\--fullchain-file /etc/nginx/ssl/cuijunyu.pem \\--reloadcmd &quot;nginx -s reload&quot; 删除已安装的证书 1acme.sh --remove -d cuijunyu.win -d &quot;*.cuijunyu.win&quot;","link":"/20230120/%E9%80%9A%E8%BF%87Acme-sh-CloudFlare-Dns%E8%AE%A4%E8%AF%81%E7%94%B3%E8%AF%B7%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6/"},{"title":"数据结构学习-队列","text":"队列是什么 队列是一种特殊的线性表, 他只允许在表的前端进行删除操作, 在表的后端进行插入操作 只有最早进入队列的元素才能最先从队列中删除, 所以队列又称为 先进先出线性表 (FIFO) 队列的实现 数组实现的队列 123456789101112131415161718192021222324252627282930313233class arrQueue { private queue: unknown[] = []; // 从队列尾部插入元素 enqueue(data: unknown) { return this.queue.push(data); } // 从队列头部删除元素 dequeue() { return this.queue.shift(); } // 返回队列头部元素 front() { return this.queue.at(0); } isEmpty() { return this.queue.length === 0; } size() { return this.queue.length; } clear() { this.queue = []; } toString() { return this.queue.join(&quot;-&quot;); }}const queue = new arrQueue(); 数组实现的队列虽然简单, 但是由于 shift 操作消耗资源大, 所以这种队列性能不高 对象实现的队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type QueueObj = { [k: number]: any;};// 使用对象实现class objectQueue { private queue: QueueObj = {}; // 开始的下标 private start = 0; // 结束的下标 private end = 0; // 从队列尾部插入元素 enqueue(data: unknown) { this.queue[this.end] = data; this.end++; return this.queue[this.end - 1]; } // 从队列头部删除元素 dequeue() { if (this.size() &gt; 0) { let item = this.queue[this.start]; delete this.queue[this.start]; this.start++; return item; } else return undefined; } // 返回队列头部元素 front() { return this.queue[this.start]; } isEmpty() { return this.size() === 0; } size() { return this.end - this.start; } clear() { this.queue = {}; this.start = 0; this.end = 0; } toString() { let str = &quot;&quot;; for (let index = this.start; index &lt; this.end; index++) { str += this.queue[index] + &quot; &quot;; } return str; }} 双端队列 双端队列（Double-ended queue，简称 deque）是一种具有队列和栈的性质的数据结构，它允许从两端添加和删除元素。 实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071type DoubleQueue = { [k: number]: any;};// 使用对象实现class doubleQueue { private queue: DoubleQueue = {}; // 开始的下标 private start = 0; // 结束的下标 private end = 0; // 从队列头部添加元素 addFront(data: any) { this.start--; this.queue[this.start] = data; return this.queue[this.start]; } // 从队列尾部插入元素 addBack(data: unknown) { this.queue[this.end] = data; this.end++; return this.queue[this.end - 1]; } // 从队列头部删除元素 delFront() { if (this.size() &gt; 0) { const item = this.queue[this.start]; delete this.queue[this.start]; this.start++; return item; } else return undefined; } // 从队列尾部删除元素 delBack() { if (this.size() &gt; 0) { const item = this.queue[this.end - 1]; delete this.queue[this.end - 1]; this.end--; return item; } else return undefined; } // 返回队列头部元素 peekFront() { return this.queue[this.start]; } // 返回队列尾部元素 peekBack() { return this.queue[this.end - 1]; } isEmpty() { return this.size() === 0; } size() { return this.end - this.start; } clear() { this.queue = {}; this.start = 0; this.end = 0; } toString() { let str = &quot;&quot;; for (let index = this.start; index &lt; this.end; index++) { str += this.queue[index] + &quot; &quot;; } return str; }} 队列的应用 击鼓传花游戏 12345678910111213141516171819202122// 击鼓传花游戏function game(list: Array&lt;string&gt;, num: number) { let queue = new objectQueue(); // 先把人员入栈 for (let i = 0; i &lt; list.length; i++) { queue.enqueue(list[i]); } // 停止条件是 队列中只有一个元素 while (queue.size() &gt; 1) { for (let i = 0; i &lt; num; i++) { // 将队列头部的元素添加到队尾 queue.enqueue(queue.dequeue()); } // 循环结束队头的就是出局者 console.log(queue.dequeue() + &quot;淘汰了&quot;); } // 只有一个元素的话 这就是获胜者 console.log(queue.dequeue() + &quot;胜利&quot;);}game([&quot;tim&quot;, &quot;tom&quot;, &quot;jack&quot;, &quot;nana&quot;, &quot;tina&quot;], 7); 检查回文数 (双端队列) 12345678910111213141516171819202122// 回文数检查function check(str: string) { // 全部转小写, 去掉空格 str = str.toLocaleLowerCase().split(&quot; &quot;).join(&quot;&quot;); console.log(&quot;处理后的字符串:&quot; + str); // 将字符串加入队列 const que = new doubleQueue(); for (let i = 0; i &lt; str.length; i++) { que.addBack(str[i]); } let tag = true; // 取出首尾元素进行对比 while (que.size() &gt; 1) { if (que.delFront() != que.delBack()) { tag = false; break; } } console.log(tag);}check(&quot;abc dc bA&quot;);","link":"/20230306/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%98%9F%E5%88%97/"},{"title":"通过nginx反代openai api","text":"最近 openai 发布了 chatGPT 同款的 GPT-3.5 trubo API, 并且价格十分低廉, 正当大家跃跃欲试的时候却发现 GFW 却已经先我们一步了… 那么解决方案也很简单, 首先你需要一台安装了 nginx 境外服务器, 然后配置如下即可使用 1234567891011121314server { listen 8443 ssl; server_name openai.example.com; ssl_certificate /etc/nginx/ssl/cuijunyu.pem; ssl_certificate_key /etc/nginx/ssl/cuijunyu.key; ssl_protocols TLSv1.2 TLSv1.3; location / { proxy_pass https://api.openai.com/; proxy_set_header Host api.openai.com; proxy_set_header X-Real-IP $remote_addr; }} 请求 api 的时候, 你只需要把 URL 换成 openai.example.com 就可以了","link":"/20230306/%E9%80%9A%E8%BF%87nginx%E5%8F%8D%E4%BB%A3openai-api/"},{"title":"ts-node调试ESM项目提示[ERR_UNKNOWN_FILE_EXTENSION]","text":"如果直接使用 ts-node 运行开启了 ESM 的项目, 会提示未知扩展名 1234567891011121314PS C:\\学习\\前端\\VoiceGPT\\voiceGPT-backend&gt; ts-node .\\src\\index.tsTypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension &quot;.ts&quot; for C:\\学习\\前端\\VoiceGPT\\voiceGPT-backend\\src\\index.ts at new NodeError (node:internal/errors:399:5) at Object.getFileProtocolModuleFormat [as file:] (node:internal/modules/esm/get_format:79:11) at defaultGetFormat (node:internal/modules/esm/get_format:121:38) at defaultLoad (node:internal/modules/esm/load:81:20) at nextLoad (node:internal/modules/esm/loader:163:28) at ESMLoader.load (node:internal/modules/esm/loader:605:26) at ESMLoader.moduleProvider (node:internal/modules/esm/loader:457:22) at new ModuleJob (node:internal/modules/esm/module_job:64:26) at ESMLoader.#createModuleJob (node:internal/modules/esm/loader:480:17) at ESMLoader.getModuleJob (node:internal/modules/esm/loader:434:34) { code: 'ERR_UNKNOWN_FILE_EXTENSION'} 解决方法: 将运行命令改为 1ts-node --esm .\\src\\index.ts","link":"/20230307/ts-node%E8%B0%83%E8%AF%95ESM%E9%A1%B9%E7%9B%AE/"},{"title":"数据结构学习-集合与字典","text":"集合 Set 是一种数据结构，用于存储唯一值的集合。它类似于数组，但不允许重复元素。 代码实现 1234567891011121314151617181920212223242526272829303132333435363738class mySet { item = {} as { [key: string]: any; }; add(element: any) { if (!this.has(element)) { this.item[element] = element; return true; } return false; } delete(element: any) { if (this.has(element)) { delete this.item[element]; return true; } return false; } has(element: any) { return element in this.item; } clear() { this.item = {}; return true; } size() { return Reflect.ownKeys(this.item).length; } values() { return Object.values(this.item); }} ES6 的 Set 结构 创建一个新的 Set 对象：可以通过以下任意一种方式创建一个 Set 对象： 12let set = new Set(); // 空集合let set = new Set([1, 2, 3]); // 包含了元素 1，2 和 3 的集合 添加元素到集合中：可以使用 add()方法向集合中添加元素： 1234let set = new Set();set.add(1);set.add(2);set.add(3); 删除集合中的元素：可以使用 delete()方法删除集合中的元素： 12let set = new Set([1, 2, 3]);set.delete(2); 检查集合中是否存在某个元素：可以使用 has()方法来检查集合中是否存在某个元素： 123let set = new Set([1, 2, 3]);set.has(2); // 返回 trueset.has(4); // 返回 false 获取集合的大小：可以使用 size 属性获取集合中元素的数量： 12let set = new Set([1, 2, 3]);set.size; // 返回 3 迭代集合中的元素：可以使用 for…of 循环或者 forEach()方法来迭代 Set 中的所有元素： 12345678let set = new Set([1, 2, 3]);for (let item of set) { console.log(item);}set.forEach(function (value) { console.log(value);}); 利用 set 取并集, 交集, 差集 1234567891011121314151617// 取交集并集差集const setA = new Set([1, 2, 3, 4, 5]);const setB = new Set([3, 4, 5, 6, 7]);// 并集const c = new Set([...setA, ...setB]);console.log(c);// 交集const d = new Set([...setA].filter((item) =&gt; setB.has(item)));console.log(d);// 差集// 给定两个集合A和B，它们的差集是指包含所有属于集合A但不属于集合B的元素所构成的集合// setA的差集const e = new Set([...setA].filter((item) =&gt; !setB.has(item)));console.log(e); 字典 字典和集合很类似, 集合以(值, 值)的形式存储数据, 字典则以(键, 值) 的形式存储数据, 字典也成为映射, 符号表, 或关联数组 ES6 中的 Set 和 Map 都是集合（collection）类型，但它们有一些区别： Set ​ 是一组有序且唯一的值的集合，而 Map ​ 是一组键值对(key-value)的集合。 在 Set ​ 中，每个元素只出现一次，可以用来去重；在 Map ​ 中，每个键(key)只能对应一个值(value)，但同一个值可以被多个键所对应。 Set ​ 采用类似数组的方式来访问其成员，而 Map 则采用键来访问其成员。 Set ​ 的主要方法包括 add、delete、has、clear ​ 等，而 Map ​ 的主要方法包括 set、get、has、delete、clear ​ 等。 因此，如果需要存储一组唯一的值或进行去重操作，可以使用 Set；如果需要存储键值对，并且需要通过键来访问其对应的值，则可以使用 Map。 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Dictionary { table = {} as { [k: string]: any; }; toStr(item: any) { if (item === null) return &quot;null&quot;; if (item === undefined) return &quot;undefined&quot;; if (typeof item === &quot;string&quot; || item instanceof String) return item as string; return JSON.stringify(item); } set(key: any, value: any) { if (key !== null &amp;&amp; value !== null) { this.table[this.toStr(key)] = new keyPair(key, value); return true; } return false; } get(key: any) { const value = this.table[this.toStr(key)]?.value; if (value) { return value; } return undefined; } hasKey(key: any) { return this.table[this.toStr(key)] != null; } keys() { return this.keyValues().map((item) =&gt; item.key); } values() { return this.keyValues().map((item) =&gt; item.value); } keyValues() { return Object.values(this.table); } size() { return Object.keys(this.table).length; } isEmpty() { return this.size() === 0; } clear() { this.table = {}; } foreach(cb: Function) { const pair = this.keyValues(); for (let i = 0; i &lt; this.size(); i++) { cb(pair[i].key, pair[i].value); } }}class keyPair { key: any; value: any; constructor(key: any, value: any) { this.key = key; this.value = value; }}const dir = new Dictionary(); hashMap 散列表 散列表将 key 通过一个散列函数转化为固定长度, 解决了字典结构如果 key 过长会造成查找时间过长的问题 散列表的代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445import { keyPair } from &quot;./map&quot;;class hashMap { table = {} as { [k: string]: any; }; toStr(item: any) { if (item === null) return &quot;null&quot;; if (item === undefined) return &quot;undefined&quot;; if (typeof item === &quot;string&quot; || item instanceof String) return item as string; return JSON.stringify(item); } hashCode(key: any) { // 将对象转换为字符串, 然后将字符串的ascii码值相加, 最后取余 if (typeof key === &quot;number&quot;) { return key; } const tableKey = this.toStr(key); let hash = 5381; [...tableKey].forEach((item) =&gt; { hash = hash * 33 + item.charCodeAt(0); }); return hash % 1013; } set(key: any, value: any) { if (key &amp;&amp; value) { const position = this.hashCode(key); this.table[position] = new keyPair(key, value); return true; } return false; } get(key: any) { return this.table[this.hashCode(key)]; } remove(key: any) { const hash = this.hashCode(key); if (this.table[hash]) { delete this.table[hash]; return true; } return false; }} ES6 的 Map ES6 中的 Map 结构可以用来存储键值对，其使用方法如下： 创建一个空的 Map 对象 1const myMap = new Map(); 添加键值对到 Map 中 1myMap.set(key, value); 从 Map 中获取某个键对应的值 1const value = myMap.get(key); 检查 Map 中是否存在指定的键 1const hasKey = myMap.has(key); 获取 Map 中所有的键或值 12const keys = myMap.keys();const values = myMap.values(); 获取 Map 中键值对的数量 1const size = myMap.size; 遍历 Map 中的所有键值对 123myMap.forEach((value, key) =&gt; { // 处理每个键值对}); 需要注意的是，Map 中的键可以是任何类型的值，而不仅限于字符串和数字。此外，Map 也提供了其他一些有用的方法，比如删除特定键的值，清空 Map 等。 WeakMap 和 WeakSet WeakMap 和 WeakSet 是 ES6 中新增的两种集合类型，它们都具有以下特点： 只能存储对象作为键，不能使用原始值类型（如字符串、数字等）作为键。 对于存储在集合中的对象，当没有其他对象引用它们时，它们会被自动回收。 其中，WeakMap 是一种以弱引用方式存储键值对的类似 Map 的数据结构。与 Map 不同的是，WeakMap 中的键只能是对象，而且这些对象都是弱引用的。也就是说，当某个对象作为 WeakMap 的键时，如果没有其他对象引用该键所对应的对象，则这个键值对会被自动从 WeakMap 中删除，以释放其占用的内存。 以下是一个使用 WeakMap 的示例： 1234567891011const myWeakMap = new WeakMap();const key = {}; // 创建一个新对象myWeakMap.set(key, &quot;value&quot;); // 将这个对象作为键存储到 WeakMap 中console.log(myWeakMap.get(key)); // 输出 &quot;value&quot;key = null; // 将原来的键对象置为 null// 由于没有任何其他对象引用这个键所对应的值，因此这个键值对会被自动删除 另一方面，WeakSet 是一种以弱引用方式存储对象的类似 Set 的数据结构。与 Set 不同的是，WeakSet 中的元素只能是对象，而且这些对象都是弱引用的。也就是说，当某个对象作为 WeakSet 的元素时，如果没有其他对象引用该元素，则这个元素会被自动从 WeakSet 中删除，以释放其占用的内存。 以下是一个使用 WeakSet 的示例： 12345678910111213const myWeakSet = new WeakSet();const obj1 = {}; // 创建两个新对象const obj2 = {};myWeakSet.add(obj1); // 将这两个对象添加到 WeakSet 中myWeakSet.add(obj2);console.log(myWeakSet.has(obj1)); // 输出 trueobj1 = null; // 将 obj1 置为 null// 由于没有任何其他对象引用 obj1，因此它会被自动从 WeakSet 中删除","link":"/20230312/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%9B%86%E5%90%88%E4%B8%8E%E5%AD%97%E5%85%B8/"},{"title":"数据结构学习-链表","text":"链表 链表是一种物理存储单元上非连续, 非顺序的存储结构, 数据元素的逻辑顺序是通过链表指针实现的, 链表由一些列结点组成, 每个节点包含两个部分: 一个是存储数据元素的数据域, 另一个是存储下一个结点地址的指针域 链表结构可以充分利用计算机内存空间, 实现灵活的内存动态管理, 但是链表失去了数组孙继读取的优点, 同时链表由于增加了结点的指针域, 空间开销比较大 链表的特点 插入删除效率高 O(1), 只需要改变指针指向即可, 随机访问效率低 O(n)(需要从链头到链尾遍历) 与数组相比, 内存空间消耗更大, 因为每个存储数据的节点都需要额外的空间存储后继指针 ‍ ‍ 单链表 单链表的每一个节点, 都包含了数据区域和 next 指向下一个节点的指针 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142class LinkNode { element: any; next: LinkNode | null | undefined; constructor(element: any) { this.element = element; this.next = null; }}class LinkedList { count: number; head: LinkNode | null | undefined; constructor() { this.count = 0; this.head = null; } push(element: any) { // 新建节点 const newNode = new LinkNode(element); // 如果链表为空 if (!this.head) { this.count++; this.head = newNode; } else { this.count++; let current = this.head; // 遍历链表, 直到最后一个元素 while (current.next) { current = current.next; } current.next = newNode; } return newNode; } // 删除指定位置的节点 removeAt(index: number) { let removeNode: LinkNode | null | undefined; if (index &lt; 0 || index &gt;= this.count || this.count === 0) { return undefined; } else { // 如果删除第一个元素 if (index == 0) { // 头指针指向第二个元素 removeNode = this.head; this.head = removeNode?.next; this.count--; console.log(&quot;要删除的元素是&quot; + removeNode?.element); return removeNode?.element; } else { // 如果删除的不是第一个元素 // 找到他的前一个元素 const prev = this.getNodeAt(index - 1); removeNode = prev?.next; console.log(&quot;要删除的元素是&quot; + removeNode?.element); // 要删除的元素前一个元素的next=要删除的元素后一个元素 prev!.next = removeNode?.next; this.count--; } return removeNode?.element; } } remove(element: any) { const index = this.indexOf(element); if (index === -1) { return undefined; } else { return this.removeAt(index); } } indexOf(element: any) { // 根据数据, 返回索引 let current = this.head; let index = 0; while (current?.next) { if (JSON.stringify(current.element) == JSON.stringify(element)) { return index; } index++; current = current?.next; } return -1; } getNodeAt(index: number) { let current = this.head; if (index &lt; 0 || index &gt;= this.count || this.count === 0) { return undefined; } else { for (let i = 0; i &lt; index; i++) { current = current?.next; } return current; } } toString() { let current = this.head; let str = &quot;&quot;; while (current) { str += JSON.stringify(current.element) + &quot;-&quot;; current = current?.next; } return str; } insertElement(element: any, index: number) { if (index &lt; 0 || index &gt; this.count) { return undefined; } // 如果插入最后一个元素 if (index === this.count) { return this.push(element); } const newNode = new LinkNode(element); // 如果在第一个元素之前插入 if (index === 0) { this.count++; newNode.next = this.head; this.head = newNode; return this.head; } // 在指定位置插入一个元素 // 新建一个节点, 新节点的next=插入位置的next, 插入位置的next=新节点, // 插入位置的节点 const insertedNode = this.getNodeAt(index - 1); if (insertedNode) { this.count++; newNode.next = insertedNode?.next; insertedNode.next = newNode; return newNode; } else { return undefined; } } size() { return this.count; } isEmpty() { return this.size() === 0; }} ‍ ‍ 单链表的应用 1234567891011121314151617181920212223// 回文数检查function check(str: string) { // 全部转小写, 去掉空格 str = str.toLocaleLowerCase().split(&quot; &quot;).join(&quot;&quot;); console.log(&quot;处理后的字符串:&quot; + str); // 将字符串加入队列 const list = new LinkedList(); for (let i = 0; i &lt; str.length; i++) { list.push(str[i]); } let tag = true; // 取出首尾元素进行对比 while (list.size() &gt; 1) { if (list.removeAt(0) !== list.removeAt(list.size() - 1)) { tag = false; break; } } console.log(tag);}check(&quot;abc dc bA&quot;); 双向链表 节点除了数据区域外, 还有两个指针, 分别为前驱指针 prev 和后继指针 next 在双向链表中删除元素需要考虑以下边界条件： 如果链表为空，不能进行删除操作。 如果要删除的元素是头结点或者尾节点，则需要更新 head​ 或 tail​ 指针。 如果要删除的元素不是头节点或尾节点，则需要更新其前驱节点的 next​ 指针和后继节点的 prev​ 指针。 如果输入的索引超出链表长度，应该返回 undefined​。 特别地，如果链表只有一个元素，那么删除唯一一个元素后，需要将 head​ 和 tail​ 指针都置为 null​。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import { LinkNode, LinkedList } from &quot;./单链表&quot;;class doubleLinkNode extends LinkNode { prev: doubleLinkNode | null | undefined; next: doubleLinkNode | null | undefined; constructor(element: any) { super(element); this.prev = null; }}class doubleLinkList extends LinkedList { head: doubleLinkNode | null | undefined; tail: doubleLinkNode | null | undefined; constructor() { super(); this.tail = null; } push(element: any): doubleLinkNode { const node = new doubleLinkNode(element); // 如果链表内没有元素, // 直接添加 if (this.head == null) { this.head = node; this.tail = node; } else { // 如果链表内有元素 // 当前的最后一个元素的next指向新元素, // 新元素的prev指向当前的元素 // 改变tail的指向 this.tail!.next = node; node.prev = this.tail; this.tail = node; } this.count++; return node; } insert(element: any, index: number) { // 首先判断index是否符合条件 if (index &lt; 0 || index &gt; this.count) { return undefined; } const node = new doubleLinkNode(element); if (index === 0) { // 如果没有元素 if (!this.head) { this.head = node; this.tail = node; } else { // 如果有元素想要插入最前 node.next = this.head; this.head.prev = node; this.head = node; } } else if (index === this.count) { // 如果是在最后插入 this.tail!.next = node; node.prev = this.tail; this.tail = node; } else { // 在内部插入 // 前一个结点的next=新节点 // 后一个节点的prev=新节点 // 新节点的prev=前一个结点 // 新节点的next=后一个节点 const prevNode = this.getNodeAt(index - 1) as doubleLinkNode; const nextNode = this.getNodeAt(index) as doubleLinkNode; prevNode.next = node; nextNode.prev = node; node.prev = prevNode; node.next = nextNode; } this.count++; return node; } removeAt(index: number) { //在双向链表中删除元素需要考虑以下边界条件： // 如果链表为空，不能进行删除操作。 // 如果要删除的元素是头结点或者尾节点，则需要更新 head 或 tail 指针。 // 如果要删除的元素不是头节点或尾节点，则需要更新其前驱节点的 next 指针和后继节点的 prev 指针。 // 如果输入的索引超出链表长度，应该返回 undefined。 // 特别地，如果链表只有一个元素，那么删除唯一一个元素后，需要将 head 和 tail 指针都置为 null。 if (index &lt; 0 || index &gt;= this.count || this.count == 0) { return undefined; } let current: doubleLinkNode | null | undefined; if (index === 0) { current = this.head; if (this.count === 1) { this.head = null; this.tail = null; } else { this.head = current?.next; this.head!.prev = null; } } else if (index === this.count - 1) { // 删除最后的元素 current = this.tail; this.tail = current?.prev; this.tail!.next = null; } else { // 删除中间的元素 const prevNode = this.getNodeAt(index - 1) as doubleLinkNode; current = prevNode.next; prevNode.next = current?.next; current!.next!.prev = prevNode; } this.count--; return current; }} ‍ 循环链表 循环列表的最后一个结点的 next 指向 head 结点 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import { LinkNode, LinkedList } from &quot;./单链表&quot;;class circularLinkedList extends LinkedList { constructor() { super(); } push(element: any): LinkNode { const newNode = new LinkNode(element); // 如果空表 if (this.count === 0) { this.head = newNode; } else { const current = this.getNodeAt(this.count - 1); current!.next = newNode; } newNode.next = this.head; this.count++; return newNode; } insertElement(element: any, index: number): LinkNode | undefined { if (index &lt; 0 || index &gt; this.count) { return; } const newNode = new LinkNode(element); let current = this.head; if (index === 0) { // 如果没有元素 if (this.count === 0) { this.head = newNode; newNode.next = this.head; } else { newNode.next = current; this.head = newNode; // 将最后的元素重新指向头 current = this.getNodeAt(this.count - 1); current!.next = this.head; } } else { // 在中间插入 current = this.getNodeAt(index - 1); newNode.next = current?.next; current!.next = newNode; } this.count++; return newNode; } removeAt(index: number) { if (index &lt; 0 || index &gt;= this.count || this.count === 0) { return; } let current = this.head; if (index === 0) { if (this.count === 1) { // 如果只有一个元素 this.head = null; } else { let last = this.getNodeAt(this.count - 1); this.head = current?.next; last!.next = this.head; } } else { current = this.getNodeAt(index - 1); current!.next = current?.next?.next; } this.count--; return current; }} ‍","link":"/20230308/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0-%E9%93%BE%E8%A1%A8/"},{"title":"FlexBox总结","text":"Flex 布局有两种属性: 容器属性/项目属性 容器属性 flex-direction 主轴方向 取值: row: 水平, 默认 row-reverse: 水平, 从右往左 column: 垂直 column: 垂直, 从下往上 flex-wrap 项目换行 取值 nowrap: 不换行, 默认 wrap: 换行 wrap-reverse: 反向换行, 表现得与align-items设置为flex-end类似 当启用换行时, 每一行都有一个主轴 flex-flow 主轴方向和项目换行的简写 flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; justify-content 主轴对齐方式 取值 flex-start: 主轴开头, 默认 flex-end: 主轴末尾 center: 主轴中心 space-between: 两侧无间距, 项目之间间距相同 space-around: 两侧间距较小, 项目之间间距相同 align-items 交叉轴对齐方式 取值 flex-start: 交叉轴开头, 默认 flex-end: 交叉轴末尾 center: 交叉轴中心 stretch: 拉伸到可用宽度 baseline: 基线对齐 align-content 多行交叉轴对齐方式 取值 flex-start: 交叉轴开头, 默认 flex-end: 交叉轴末尾 center: 交叉轴中心 stretch: 拉伸到可用宽度 space-between: 两侧无间距, 项目之间间距相同 space-around: 两侧间距较小, 项目之间间距相同 注意点: 如果启用换行, 那么align-content生效, 否则无效 如果启用换行, 只有align-content为stretch时, align-items才会生效 项目属性 order 项目顺序 order 项目排列顺序 取值：整数，越小越靠前，默认为 0。 flex-grow 项目放大比例 取值：数字，默认为 0。 flex-shrink 项目收缩比例 取值：数字，默认为 1。 flex-basis 项目占据主轴的空间大小 取值： 默认值: 自适应空间 固定尺寸(如 100px) flex 简写属性 设置flex-grow、flex-shrink和flex-basis三个属性的值。默认值为0 1 auto。 align-self 指定单个项目在交叉轴上的对齐方式 取值：与align-items取值相同（但会覆盖其），也包括其余有效的 CSS 属性值（justify-content, align-content 等） 取值: 数字, 默认为 0 项目按照数字从小到大排序 flex-grow 项目的增长比例 取值: 数字, 默认为 0 项目如何占据剩余可用空间, 设置为 0 不占用 flex-shrink 项目的缩小比例 取值: 数字, 默认为 1","link":"/20230419/FlexBox%E6%80%BB%E7%BB%93/"},{"title":"在Snipaste中支持ocr[需高级版]","text":"Snipaste 是一款非常好用的截图软件, 但是却缺少了一个非常重要的功能–ocr 在作者帮助下, 我成功的让 Snipaste 支持了 ocr 功能, 此功能需要高级版的 [自定义命令] 功能搭配 tesseract-ocr 实现 ocr 功能, 而且体验很好 配置过程 前往 https://digi.bib.uni-mannheim.de/tesseract/ 下载安装最新版​ tesseract-ocr, 安装过程中, 选择中文识别包 安装完成之后, 可以使用如下命令进行本地 ocr: 1. tesseract &lt;需 ocr 的图像&gt; &lt;输出文件位置, 注意不需要写扩展名&gt; -c preserve_interword_spaces=1 --oem 1 --psm 1 -l eng+chi_sim 其中-c preserve_interword_spaces=1 --oem 1 --psm 1 -l eng+chi_sim 为识别参数, preserve_interword_spaces=1可以去掉多余的空格, -l eng+chi_sim 是指定识别语言 打开 Snipaste 的首选项-控制, 点击添加新命令 名称随意填写, 命令填写如下 1snip -o &quot;D:\\Temp\\source.png&quot;;exec(cmd /c &quot;C:\\Program Files\\Tesseract-OCR\\tesseract.exe&quot; &quot;D:\\Temp\\source.png&quot; &quot;D:\\Temp\\ocrRes&quot; -c preserve_interword_spaces=1 --oem 1 --psm 1 -l eng+chi_sim &amp;&amp; notepad &quot;D:\\Temp\\ocrRes.txt&quot;); 这段命令的含义是首先调用 Snipaste 截图并存放于D:\\Temp\\source.png, 然后执行 cmd 命令, 调用tesseract进行 ocr 识别, 并将识别结果用记事本打开 其中, **C:\\Program Files\\Tesseract-OCR\\tesseract.exe**为你的tesseract安装路径, D:\\Temp\\ocrRes为 ocr 结果的文件路径, 注意只需要写文件名, 不需要拓展名, 文件名和路径请根据自己需要修改 随后指定一个快捷键即可愉快的 OCR 啦 !! 😋😋😋😋😋","link":"/20230310/%E5%9C%A8Snipaste%E4%B8%AD%E6%94%AF%E6%8C%81ocr-%E9%9C%80%E9%AB%98%E7%BA%A7%E7%89%88/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"typeScript","slug":"typeScript","link":"/tags/typeScript/"},{"name":"pwa","slug":"pwa","link":"/tags/pwa/"},{"name":"小工具","slug":"小工具","link":"/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"name":"pandoc","slug":"pandoc","link":"/tags/pandoc/"},{"name":"CloudFlare","slug":"CloudFlare","link":"/tags/CloudFlare/"},{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"openai","slug":"openai","link":"/tags/openai/"},{"name":"ocr","slug":"ocr","link":"/tags/ocr/"},{"name":"snipaste","slug":"snipaste","link":"/tags/snipaste/"}],"categories":[],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"about","text":"","link":"/about/index.html"}]}